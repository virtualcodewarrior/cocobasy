{"version":3,"sources":["../src/web-component-base-class.js"],"names":["createQuickAccess","dashesToCamelCase","camelCaseToDashes","base","WebComponentBaseClass","HTMLElement","eventHandlers","props","is","this","tagName","toLowerCase","template","properties","observedAttributes","Object","keys","map","name","constructor","super","$","undefined","$$","$$$","console","assert","createShadowDOM","addAutoEventListener","element","eventName","callback","cleanupFunction","find","handler","event","push","addEventListener","removeAutoEventListener","eventIndex","findIndex","splice","removeEventListener","refreshQuickAccess","shadowRoot","connectedCallback","handleConnected","attached","onAttached","defineProperty","get","set","disconnectedCallback","detached","onDetached","forEach","attributeChangedCallback","attribute","oldValue","newValue","propertyName","ensureQuickAccess","type","Boolean","selector","querySelector","Array","from","querySelectorAll","originalValues","propertyKey","property","attributeName","value","toAttribute","convertValue","toString","JSON","parse","isArray","stringify","Number","String","observer","warn","reflectToAttribute","setAttribute","removeAttribute","userInitialized","originalValue","hasAttribute","getAttribute","componentTemplate","tempDiv","document","createElement","innerHTML","trim","templateInstance","firstChild","HTMLTemplateElement","attachShadow","mode","appendChild","content","cloneNode"],"mappings":"4BAASA,uBAAmBC,uBAAmBC,MAAyB,aAExE,MAAMC,EAAO,oCACN,MAAMC,8BAA8BC,YAC1CC,GACAC,GAeIC,SAAO,OAAOC,KAAKC,QAAQC,eAAiBR,EAOrCS,sBAAa,MAAO,GAMpBC,wBAAe,MAAO,GAMtBC,gCAAuB,OAAQL,KAAe,WAAIM,OAAOC,KAAKP,KAAKI,YAAYI,KAAKC,GAAShB,EAAkBgB,KAAS,GAKnIC,cACCC,QACAX,MAAKF,EAAS,GACdE,KAAKY,OAAIC,EACTb,KAAKc,GAAK,OACVd,KAAKe,IAAM,IAAM,GACjBC,QAAQC,OAAOjB,KAAKD,KAAOL,EAAM,wHACjCM,MAAKkB,EAAiBlB,KAAKU,YAAYP,UACvCH,MAAKH,EAAiB,GAUvBsB,qBAAqBC,EAASC,EAAWC,GACxC,IAAIC,EAMJ,OALKvB,MAAKH,EAAe2B,MAAMC,GAAYA,EAAQL,UAAYA,GAAWK,EAAQC,QAAUL,GAAaI,EAAQA,UAAYH,MAC5HtB,MAAKH,EAAe8B,KAAK,CAAEP,QAAAA,EAASM,MAAOL,EAAWI,QAASH,IAC/DF,EAAQQ,iBAAiBP,EAAWC,GACpCC,EAAkB,IAAMvB,KAAK6B,wBAAwBT,EAASC,EAAWC,IAEnEC,EASRM,wBAAwBT,EAASC,EAAWC,GAC3C,MAAMQ,EAAa9B,MAAKH,EAAekC,WAAWN,GAAYA,EAAQL,UAAYA,GAAWK,EAAQC,QAAUL,GAAaI,EAAQA,UAAYH,KAC5H,IAAhBQ,IACH9B,MAAKH,EAAemC,OAAOF,EAAY,GACvCV,EAAQa,oBAAoBZ,EAAWC,IAQzCY,qBACClC,KAAKY,EAAIrB,EAAkBS,KAAKmC,WAAY,MAO7CC,oBACCpC,MAAKqC,EAAiBrC,KAAKU,YAAYN,YAEnCJ,KAAKsC,UACRtC,KAAKsC,WAGFtC,KAAKuC,YACRvC,KAAKuC,WAAWvC,MAKjBM,OAAOkC,eAAexC,KAAM,aAAc,CACzCyC,QACAC,IAAIpB,GAAYA,EAAStB,SAQ3B2C,uBAEK3C,KAAK4C,UACR5C,KAAK4C,WAGF5C,KAAK6C,YACR7C,KAAK6C,WAAW7C,MAGjBA,MAAKH,EAAeiD,SAASrB,GAAYA,EAAQL,QAAQa,oBAAoBR,EAAQC,MAAOD,EAAQA,WAUrGsB,yBAAyBC,EAAWC,EAAUC,GAC7C,MAAMC,EAAe3D,EAAkBwD,GACvChD,MAAKoD,EAAmBpD,MAEpBA,KAAKU,YAAYN,WAAW+C,IAAiBnD,KAAKU,YAAYN,WAAW+C,GAAcE,OAASC,UACnGL,KAA2B,KAAbA,GAAoBA,GAAyB,UAAbA,GAC9CC,KAA2B,KAAbA,GAAoBA,GAAyB,UAAbA,IAG3CD,IAAaC,IAChBlD,KAAKmD,GAAgBD,GASvBE,KACMpD,KAAKY,IACTZ,KAAKY,EAAIrB,EAAkBS,KAAKmC,WAAY,MAC5CnC,KAAKc,GAAMyC,GAAavD,KAAKmC,WAAWqB,cAAcD,GACtDvD,KAAKe,IAAOwC,GAAaE,MAAMC,KAAK1D,KAAKmC,WAAWwB,iBAAiBJ,KAQvElB,GAAiBjC,GAEhB,GADAJ,MAAKoD,IACDhD,EAAY,CACf,MAAMwD,EAAiB,GAEvBtD,OAAOC,KAAKH,GAAY0C,SAASe,IAChC,MAAMC,EAAW1D,EAAWyD,GACtBE,EAAgBtE,EAAkBoE,GAExCD,EAAeC,GAAe7D,KAAK6D,GAEnCvD,OAAOkC,eAAexC,KAAM6D,EAAa,CACxCpB,MAAQ,OAAOzC,MAAKF,EAAO+D,IAC3BnB,IAAIsB,GACH,MAAMf,EAAWjD,MAAKF,EAAO+D,GAC7B,IAAII,EAAeC,GAAiBA,EAAaC,WACjD,OAAQL,EAAST,MAChB,KAAKI,MACJzD,MAAKF,EAAO+D,GAAiC,iBAAVG,EAAsBI,KAAKC,MAAML,GAASP,MAAMa,QAAQN,GAASA,EAAQ,GAC5GC,EAAeC,GAAiBE,KAAKG,UAAUL,GAC/C,MACD,KAAKZ,QACJtD,MAAKF,EAAO+D,GAAeG,GAAmB,UAAVA,EACpCC,EAAc,IAAM,GACpB,MACD,KAAKO,OACJxE,MAAKF,EAAO+D,SAA2BhD,IAAVmD,EAAuB,EAAIQ,OAAOR,KAAW,EAC1E,MACD,KAAK1D,OACJN,MAAKF,EAAO+D,GAAiC,iBAAVG,EAAsBI,KAAKC,MAAML,GAA2B,iBAAVA,EAAsBA,EAAQ,GACnHC,EAAeC,GAAiBE,KAAKG,UAAUL,GAC/C,MACD,KAAKO,OACJzE,MAAKF,EAAO+D,IAAgB,MAACG,EAAyC,GAAKS,OAAOT,KAAW,GAG3FF,EAASY,WACqB,mBAAtBZ,EAASY,SACfzB,IAAajD,MAAKF,EAAO+D,IAC5BC,EAASY,SAAS1E,KAAMA,MAAKF,EAAO+D,GAAcZ,GAEzCjD,KAAK8D,EAASY,UACpBzB,IAAajD,MAAKF,EAAO+D,IAC5B7D,KAAK8D,EAASY,UAAU1E,MAAKF,EAAO+D,GAAcZ,GAGnDjC,QAAQ2D,KAAK,gCAAgCb,EAASY,8DAA8D1E,KAAKD,iEAAiE+D,EAASY,4BAGjMZ,EAASc,qBACR5E,MAAKF,EAAO+D,GACf7D,KAAK6E,aAAad,EAAeE,EAAYjE,MAAKF,EAAO+D,KAEzD7D,KAAK8E,gBAAgBf,UAO1BzD,OAAOC,KAAKH,GAAY0C,SAASe,IAChC,MAAMC,EAAW1D,EAAWyD,GACtBE,EAAgBtE,EAAkBoE,GACxC,IAAIkB,EACJ,MAAMC,EAAgBpB,EAAeC,GAErC,GAAImB,EACH,OAAQlB,EAAST,MAChB,KAAKI,MACAA,MAAMa,QAAQU,KACjBhF,KAAK6D,GAAemB,GAErB,MACD,KAAK1B,QACyB,kBAAlB0B,IACVhF,KAAK6D,GAAemB,GAErB,MACD,KAAKR,OACyB,iBAAlBQ,IACVhF,KAAK6D,GAAemB,GAErB,MACD,KAAK1E,OACyB,iBAAlB0E,IACVhF,KAAK6D,GAAemB,GAErB,MACD,KAAKP,OACyB,iBAAlBO,IACVhF,KAAK6D,GAAemB,GAUxB,GAJIhF,KAAKiF,aAAalB,KACrBgB,EAAkB/E,KAAKkF,aAAanB,IAGjCD,EAASc,yBAA4C/D,IAAtBb,KAAK6D,GAEvC,QAAwBhD,IAApBkE,EACH,OAAQjB,EAAST,MAChB,KAAKI,MACJzD,KAAK6D,GAAeO,KAAKC,MAAMU,GAC/B,MACD,KAAKzB,QACJtD,KAAK6D,GAAmC,UAApBkB,EACpB,MACD,KAAKP,OACJxE,KAAK6D,GAAeW,OAAOO,GAC3B,MACD,KAAKzE,OACJN,KAAK6D,GAAeO,KAAKC,MAAMU,GAC/B,MACD,KAAKN,OACJzE,KAAK6D,GAAeY,OAAOM,QAI7B,OAAQjB,EAAST,MAChB,KAAKI,MACJzD,KAAK6D,GAAeC,EAASE,OAAS,GACtC,MACD,KAAKV,QACJtD,KAAK6D,GAAeC,EAASE,QAAS,EACtC,MACD,KAAKQ,OACJxE,KAAK6D,GAAeC,EAASE,OAAS,EACtC,MACD,KAAK1D,OACJN,KAAK6D,GAAeC,EAASE,OAAS,GACtC,MACD,KAAKS,OACJzE,KAAK6D,GAAeC,EAASE,OAAS,QAa7C9C,GAAiBiE,GAChB,MAAMC,EAAUC,SAASC,cAAc,OACvCF,EAAQG,UAAYJ,EAAkBK,OACtC,IAAIC,EAAmBL,EAAQM,WACzBD,aAA4BE,sBACjCF,EAAmBJ,SAASC,cAAc,YAC1CG,EAAiBF,UAAYH,EAAQG,WAInBvF,KAAK4F,aAAa,CAAEC,KAAM,SAClCC,YAAYL,EAAiBM,QAAQC,WAAU","file":"web-component-base-class.js","sourcesContent":["import { createQuickAccess, dashesToCamelCase, camelCaseToDashes } from './tools.js';\n\nconst base = 'web-component-base-element';\nexport class WebComponentBaseClass extends HTMLElement {\n\t#eventHandlers;\n\t#props;\n\t/**\n\t * @property {() => void} [attached] - implement this inside your derived class to handle additional initialization after your class has been attached to the DOM\n\t * @property {(component: WebComponentBaseClass) => void} [onAttached] - assign a function to this outside your derived class to handle additional initialization after your class has been attached to the DOM\n\t * @property {() => void} [detached] - implement this inside your derived class to handle additional destruction after your class has been detached from the DOM\n\t * @property {(component: WebComponentBaseClass) => void} [onDetached] - assign a function to this outside your derived class to handle additional destruction after your class has been detached from the DOM\n\t * @property {undefined | HTMLElement} $ - directly access any elements with an id from your shadow dom, the id names will be in camelCase\n\t * @property {(selector?: string) => HTMLElement | undefined} $$ - runs querySelector on your shadow DOM\n\t * @property {(selector?: string) => HTMLElement[]} $$$ - runs querySelectorAll on your shadow DOM\n\t */\n\n\t/**\n\t * Get the name for the web component. Must be implemented by the class that extends from WebComponentBaseClass\n\t * @returns {string} The name of the web component\n\t */\n\tget is() { return this.tagName.toLowerCase() ?? base; }\n\n\t/**\n\t * Get the template. This will return empty string by default so the class that extends from this must provide its own template\n\t * This should be HTML code as a string (e.g. <div>My template content...</div>\n\t * @returns {string} The template to be used with the web component as a string\n\t */\n\tstatic get template() { return ''; }\n\n\t/**\n\t * Get the properties for this web component. Derived classes can override this if they want to provide properties. By default, there are no properties\n\t * @returns {object} The properties object\n\t */\n\tstatic get properties() { return {}; }\n\n\t/**\n\t * Get an array containing all attributes that have an observer attached\n\t * @returns {array} Array containing all attributes that have an observer\n\t */\n\tstatic get observedAttributes() { return (this.properties) ? Object.keys(this.properties).map((name) => camelCaseToDashes(name)) : []; }\n\n\t/**\n\t * Constructor for this base class\n\t */\n\tconstructor() {\n\t\tsuper();\n\t\tthis.#props = {};\n\t\tthis.$ = undefined;\n\t\tthis.$$ = () => undefined;\n\t\tthis.$$$ = () => [];\n\t\tconsole.assert(this.is !== base, 'Error, don\\'t forget to register your custom element using window.customElements.define(\\'name-of-element\\', MyElement)');\n\t\tthis.#createShadowDOM(this.constructor.template);\n\t\tthis.#eventHandlers = [];\n\t}\n\n\t/**\n\t * Attach an event handler to the given element. This function will automatically clean all event handlers when the web component gets removed from the DOM\n\t * @param {HTMLElement} element The element to which we are attaching the event handler\n\t * @param {string} eventName The name of the event (e.g. click, mouse down etc)\n\t * @param {function} callback The handler function to be called for the event\n\t * @returns {function | undefined} A function that can be used to remove this event handler or undefined if this event handler already existed\n\t */\n\taddAutoEventListener(element, eventName, callback) {\n\t\tlet cleanupFunction;\n\t\tif (!this.#eventHandlers.find((handler) => handler.element === element && handler.event === eventName && handler.handler === callback)) {\n\t\t\tthis.#eventHandlers.push({ element, event: eventName, handler: callback });\n\t\t\telement.addEventListener(eventName, callback);\n\t\t\tcleanupFunction = () => this.removeAutoEventListener(element, eventName, callback);\n\t\t}\n\t\treturn cleanupFunction;\n\t}\n\n\t/**\n\t * Remove an event handler that was previously attached by a call to addAutoEventListener\n\t * @param {HTMLElement} element The element from which the event will be removed\n\t * @param {string} eventName The name of the event to remove\n\t * @param {function} callback The callback that was previously added for the event\n\t */\n\tremoveAutoEventListener(element, eventName, callback) {\n\t\tconst eventIndex = this.#eventHandlers.findIndex((handler) => handler.element === element && handler.event === eventName && handler.handler === callback);\n\t\tif (eventIndex !== -1) {\n\t\t\tthis.#eventHandlers.splice(eventIndex, 1);\n\t\t\telement.removeEventListener(eventName, callback);\n\t\t}\n\t}\n\n\t/**\n\t * recreate the quick access object using the current content of the shadow dom\n\t * use this when you manually add items to or remove items from the DOM\n\t */\n\trefreshQuickAccess() {\n\t\tthis.$ = createQuickAccess(this.shadowRoot, 'id');\n\t}\n\n\t/**\n\t * @private\n\t * Called by the system when the web component has been added to the DOM\n\t */\n\tconnectedCallback() {\n\t\tthis.#handleConnected(this.constructor.properties);\n\t\t// this function should be implemented INSIDE the derived cass, if you want to do additional initialization after the component gets attached to the DOM\n\t\tif (this.attached) {\n\t\t\tthis.attached();\n\t\t}\n\t\t// this function should be implemented OUTSIDE the derived cass, if you want to do additional initialization after the component gets attached to the DOM\n\t\tif (this.onAttached) {\n\t\t\tthis.onAttached(this);\n\t\t}\n\n\t\t// setter to set the onAttached function, this setter only exist after the component has been attached and replaces the onAttached member\n\t\t// this will make sure that onAttached gets called immediately if the component was already attached\n\t\tObject.defineProperty(this, 'onAttached', {\n\t\t\tget() { return undefined; },\n\t\t\tset(callback) { callback(this); },\n\t\t});\n\t}\n\n\t/**\n\t * @private\n\t * Called by the system when the web component has been removed from the DOM\n\t */\n\tdisconnectedCallback() {\n\t\t// this function should be implemented INSIDE the derived class when needed to handle the component being removed from the DOM\n\t\tif (this.detached) {\n\t\t\tthis.detached();\n\t\t}\n\t\t// this function can be implemented OUTSIDE of the derived class, if you want to be notified if the component has been removed from the DOM\n\t\tif (this.onDetached) {\n\t\t\tthis.onDetached(this);\n\t\t}\n\t\t// remove any auto event handler that was added\n\t\tthis.#eventHandlers.forEach((handler) => handler.element.removeEventListener(handler.event, handler.handler));\n\t}\n\n\t/**\n\t * @private\n\t * Called by the system if an attribute value is changed\n\t * @param {string} attribute The name of the attribute that is changed\n\t * @param {*} oldValue The old value for the attribute\n\t * @param {*} newValue The new value for the attribute\n\t */\n\tattributeChangedCallback(attribute, oldValue, newValue) {\n\t\tconst propertyName = dashesToCamelCase(attribute);\n\t\tthis.#ensureQuickAccess(this);\n\t\t// boolean are handled differently because the absence of the value also means false and the presence of the value also means true\n\t\tif (this.constructor.properties[propertyName] && this.constructor.properties[propertyName].type === Boolean) {\n\t\t\toldValue = !!(oldValue === '' || (oldValue && oldValue !== 'false'));\n\t\t\tnewValue = !!(newValue === '' || (newValue && newValue !== 'false'));\n\t\t}\n\t\t// we set our variable and the setter will handle the rest\n\t\tif (oldValue !== newValue) {\n\t\t\tthis[propertyName] = newValue;\n\t\t}\n\t}\n\n\t/**\n\t * Create quick access members for this component. This function will add the possibility to access child elements that have an id, through\n\t * the $ member, it also allows to do a querySelector on the shadow dom through the $$ function and it will add querySelectorAll through the $$$ function\n\t * The $$$ function will return the child members as an array and not as an node list\n\t */\n\t#ensureQuickAccess() {\n\t\tif (!this.$) { // make sure we didn't do this already\n\t\t\tthis.$ = createQuickAccess(this.shadowRoot, 'id');\n\t\t\tthis.$$ = (selector) => this.shadowRoot.querySelector(selector);\n\t\t\tthis.$$$ = (selector) => Array.from(this.shadowRoot.querySelectorAll(selector));\n\t\t}\n\t}\n\n\t/**\n\t * Initialize the web component after it has been added to the DOM\n\t * @param {object} properties The object that contains any web component specific properties\n\t */\n\t#handleConnected(properties) {\n\t\tthis.#ensureQuickAccess();\n\t\tif (properties) {\n\t\t\tconst originalValues = {};\n\n\t\t\tObject.keys(properties).forEach((propertyKey) => {\n\t\t\t\tconst property = properties[propertyKey];\n\t\t\t\tconst attributeName = camelCaseToDashes(propertyKey);\n\n\t\t\t\toriginalValues[propertyKey] = this[propertyKey];\n\n\t\t\t\tObject.defineProperty(this, propertyKey, {\n\t\t\t\t\tget() { return this.#props[propertyKey]; },\n\t\t\t\t\tset(value) {\n\t\t\t\t\t\tconst oldValue = this.#props[propertyKey];\n\t\t\t\t\t\tlet toAttribute = (convertValue) => convertValue.toString();\n\t\t\t\t\t\tswitch (property.type) {\n\t\t\t\t\t\t\tcase Array:\n\t\t\t\t\t\t\t\tthis.#props[propertyKey] = (typeof value === 'string') ? JSON.parse(value) : Array.isArray(value) ? value : [];\n\t\t\t\t\t\t\t\ttoAttribute = (convertValue) => JSON.stringify(convertValue);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase Boolean:\n\t\t\t\t\t\t\t\tthis.#props[propertyKey] = value && value !== 'false';\n\t\t\t\t\t\t\t\ttoAttribute = () => '';\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase Number:\n\t\t\t\t\t\t\t\tthis.#props[propertyKey] = ((value === undefined) ? 0 : Number(value)) || 0;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase Object:\n\t\t\t\t\t\t\t\tthis.#props[propertyKey] = (typeof value === 'string') ? JSON.parse(value) : (typeof value === 'object') ? value : {};\n\t\t\t\t\t\t\t\ttoAttribute = (convertValue) => JSON.stringify(convertValue);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase String:\n\t\t\t\t\t\t\t\tthis.#props[propertyKey] = ((value === undefined || value === null) ? '' : String(value)) || '';\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (property.observer) {\n\t\t\t\t\t\t\tif (typeof property.observer === 'function') {\n\t\t\t\t\t\t\t\tif (oldValue !== this.#props[propertyKey]) {\n\t\t\t\t\t\t\t\t\tproperty.observer(this, this.#props[propertyKey], oldValue);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else if (this[property.observer]) {\n\t\t\t\t\t\t\t\tif (oldValue !== this.#props[propertyKey]) {\n\t\t\t\t\t\t\t\t\tthis[property.observer](this.#props[propertyKey], oldValue);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tconsole.warn(`The observer with the name: '${property.observer}' was not found inside the class for web component ${this.is}. Make sure that you added a public function with the name '${property.observer}' to the class.`);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (property.reflectToAttribute) {\n\t\t\t\t\t\t\tif (this.#props[propertyKey]) {\n\t\t\t\t\t\t\t\tthis.setAttribute(attributeName, toAttribute(this.#props[propertyKey]));\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tthis.removeAttribute(attributeName);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t});\n\t\t\t});\n\n\t\t\tObject.keys(properties).forEach((propertyKey) => {\n\t\t\t\tconst property = properties[propertyKey];\n\t\t\t\tconst attributeName = camelCaseToDashes(propertyKey);\n\t\t\t\tlet userInitialized;\n\t\t\t\tconst originalValue = originalValues[propertyKey];\n\n\t\t\t\tif (originalValue) {\n\t\t\t\t\tswitch (property.type) {\n\t\t\t\t\t\tcase Array:\n\t\t\t\t\t\t\tif (Array.isArray(originalValue)) {\n\t\t\t\t\t\t\t\tthis[propertyKey] = originalValue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase Boolean:\n\t\t\t\t\t\t\tif (typeof originalValue === 'boolean') {\n\t\t\t\t\t\t\t\tthis[propertyKey] = originalValue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase Number:\n\t\t\t\t\t\t\tif (typeof originalValue === 'number') {\n\t\t\t\t\t\t\t\tthis[propertyKey] = originalValue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase Object:\n\t\t\t\t\t\t\tif (typeof originalValue === 'object') {\n\t\t\t\t\t\t\t\tthis[propertyKey] = originalValue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase String:\n\t\t\t\t\t\t\tif (typeof originalValue === 'string') {\n\t\t\t\t\t\t\t\tthis[propertyKey] = originalValue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (this.hasAttribute(attributeName)) {\n\t\t\t\t\tuserInitialized = this.getAttribute(attributeName);\n\t\t\t\t}\n\n\t\t\t\tif (property.reflectToAttribute || this[propertyKey] === undefined) {\n\t\t\t\t\t// use the user specified value if it was specified\n\t\t\t\t\tif (userInitialized !== undefined) {\n\t\t\t\t\t\tswitch (property.type) {\n\t\t\t\t\t\t\tcase Array:\n\t\t\t\t\t\t\t\tthis[propertyKey] = JSON.parse(userInitialized);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase Boolean:\n\t\t\t\t\t\t\t\tthis[propertyKey] = userInitialized !== 'false';\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase Number:\n\t\t\t\t\t\t\t\tthis[propertyKey] = Number(userInitialized);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase Object:\n\t\t\t\t\t\t\t\tthis[propertyKey] = JSON.parse(userInitialized);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase String:\n\t\t\t\t\t\t\t\tthis[propertyKey] = String(userInitialized);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else { // use the default value\n\t\t\t\t\t\tswitch (property.type) {\n\t\t\t\t\t\t\tcase Array:\n\t\t\t\t\t\t\t\tthis[propertyKey] = property.value || [];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase Boolean:\n\t\t\t\t\t\t\t\tthis[propertyKey] = property.value || false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase Number:\n\t\t\t\t\t\t\t\tthis[propertyKey] = property.value || 0;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase Object:\n\t\t\t\t\t\t\t\tthis[propertyKey] = property.value || {};\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase String:\n\t\t\t\t\t\t\t\tthis[propertyKey] = property.value || '';\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Create the shadow DOM and attach it to the given web component instance\n\t * @param {string} componentTemplate The id of the web component template\n\t */\n\t#createShadowDOM(componentTemplate) {\n\t\tconst tempDiv = document.createElement('div');\n\t\ttempDiv.innerHTML = componentTemplate.trim();\n\t\tlet templateInstance = tempDiv.firstChild;\n\t\tif (!(templateInstance instanceof HTMLTemplateElement)) {\n\t\t\ttemplateInstance = document.createElement('template');\n\t\t\ttemplateInstance.innerHTML = tempDiv.innerHTML;\n\t\t}\n\n\t\t// create the shadow DOM root here\n\t\tconst shadowRoot = this.attachShadow({ mode: 'open' });\n\t\tshadowRoot.appendChild(templateInstance.content.cloneNode(true));\n\t}\n}\n"]}